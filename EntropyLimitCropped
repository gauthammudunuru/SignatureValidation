# ======================================================
# FULL END-TO-END PDF SIGNATURE BLOCK EXTRACTION
# - Keep page number
# - Keep location (bbox)
# - Remove duplicates ONLY if same page + same location
# - Two-pass entropy: normal + watermark detection
# - Mild background reduction in RGB for watermark blocks
# - Paired display: original + processed
# ======================================================

from pdf2image import convert_from_path
from PIL import Image
import numpy as np
import cv2
import matplotlib.pyplot as plt

# ======================================================
# 1. Read PDF pages
# ======================================================
pages = convert_from_path("document.pdf", dpi=300)

# ======================================================
# 2. Helpers
# ======================================================

def calculate_entropy(pil_img):
    arr = np.array(pil_img)
    # handle grayscale or RGB
    if len(arr.shape) == 3 and arr.shape[2] == 3:
        gray = cv2.cvtColor(arr, cv2.COLOR_RGB2GRAY)
    else:
        gray = arr
    hist = np.histogram(gray.flatten(), bins=256)[0]
    hist = hist / hist.sum()
    entropy = -np.sum(hist * np.log2(hist + 1e-8))
    return entropy

def detect_rectangles(pil_img, min_area=1000):
    img_np = np.array(pil_img)
    img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)

    gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(blur, 50, 150)

    contours, _ = cv2.findContours(
        edges,
        cv2.RETR_EXTERNAL,
        cv2.CHAIN_APPROX_SIMPLE
    )

    rects = []
    for c in contours:
        approx = cv2.approxPolyDP(
            c,
            0.02 * cv2.arcLength(c, True),
            True
        )

        if len(approx) == 4:
            x, y, w, h = cv2.boundingRect(approx)
            if w * h > min_area:
                rects.append((x, y, w, h))

    return rects

def is_duplicate_same_page(new_rect, existing_rects, tol=10):
    x1, y1, w1, h1 = new_rect

    for (x2, y2, w2, h2) in existing_rects:
        if (
            abs(x1 - x2) < tol and
            abs(y1 - y2) < tol and
            abs(w1 - w2) < tol and
            abs(h1 - h2) < tol
        ):
            return True

    return False

# ======================================================
# 2a. Background suppression for watermark detection
# ======================================================
def remove_background_for_filtering(pil_img):
    gray = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2GRAY)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (35,35))
    background = cv2.morphologyEx(gray, cv2.MORPH_OPEN, kernel)
    fg = cv2.subtract(gray, background)
    fg = cv2.normalize(fg, None, 0, 255, cv2.NORM_MINMAX)
    return Image.fromarray(fg)

# ======================================================
# 2b. Mild background reduction / foreground extraction
# ======================================================
def foreground_black_background_white(pil_img):
    """
    Convert a rectangle to black strokes (handwritten + printed) over white background.
    - Keeps handwriting black
    - Keeps printed text black
    - Everything else (spaces + outer area) white
    """
    gray = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2GRAY)

    # Adaptive thresholding: black text/signature, white background
    thresh = cv2.adaptiveThreshold(
        gray,
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        25,
        15
    )

    # Invert to get black strokes on white
    result = cv2.bitwise_not(thresh)

    # Convert back to RGB
    result_rgb = cv2.cvtColor(result, cv2.COLOR_GRAY2RGB)

    return Image.fromarray(result_rgb)

# ======================================================
# 3. Process all pages with two-pass entropy
# ======================================================
LOW_ENTROPY = 2.0
HIGH_ENTROPY_CANDIDATE = 4.5  # possible watermark blocks

final_crops = []

for page_idx, page in enumerate(pages):

    rects = detect_rectangles(page)

    # remove duplicates only within THIS page
    unique_rects = []
    for r in rects:
        if not is_duplicate_same_page(r, unique_rects):
            unique_rects.append(r)

    # crop + entropy filter
    for (x, y, w, h) in unique_rects:
        crop = page.crop((x, y, x+w, y+h))
        entropy = calculate_entropy(crop)

        # 1️⃣ normal signature block
        if entropy < LOW_ENTROPY:
            final_crops.append({
                "page": page_idx + 1,
                "bbox": (x, y, w, h),
                "entropy": entropy,
                "image": crop
            })
            continue

        # 2️⃣ high-entropy watermark candidates
        if entropy < HIGH_ENTROPY_CANDIDATE:
            fg_img = remove_background_for_filtering(crop)
            fg_img_rgb = fg_img.convert("RGB")
            new_entropy = calculate_entropy(fg_img_rgb)

            if new_entropy < LOW_ENTROPY+1:
                processed_img = foreground_black_background_white(crop)
                final_crops.append({
                    "page": page_idx + 1,
                    "bbox": (x, y, w, h),
                    "entropy": entropy,
                    "image": processed_img
                })
                print(f"Recovered watermark block at page {page_idx+1}, bbox {(x, y, w, h)}, new entropy={new_entropy:.2f}")

print(f"Total cropped images after filtering: {len(final_crops)}")

# ======================================================
# 4. Display paired original vs processed images
# ======================================================
def show_original_vs_processed(crops, processed_func, title="Original vs Processed"):
    """
    Display each cropped rectangle as two images:
    [ Original | Processed ]
    """
    if len(crops) == 0:
        print("No images to display.")
        return

    plt.figure(figsize=(10, 5*len(crops)))

    for i, item in enumerate(crops):
        original_img = item["image"] if 'original' not in item else item['original']
        # For processed display, use the already processed image
        processed_img = item["image"]

        p = item["page"]
        x, y, w, h = item["bbox"]
        ent = item["entropy"]

        # Original
        plt.subplot(len(crops), 2, i*2+1)
        plt.imshow(original_img)
        plt.axis("off")
        plt.title(f"Original\nP{p} | ({x},{y})\nEntropy={ent:.2f}", fontsize=9)

        # Processed
        plt.subplot(len(crops), 2, i*2+2)
        plt.imshow(processed_img)
        plt.axis("off")
        plt.title(f"Processed\nP{p} | ({x},{y})", fontsize=9)

    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

# Before adding processed image, save original crop in 'original' key for display
for item in final_crops:
    item['original'] = pages[item['page']-1].crop((
        item['bbox'][0],
        item['bbox'][1],
        item['bbox'][0]+item['bbox'][2],
        item['bbox'][1]+item['bbox'][3]
    ))

# Show paired view
show_original_vs_processed(final_crops, foreground_black_background_white,
                           title="Signatures: Original vs Processed")
