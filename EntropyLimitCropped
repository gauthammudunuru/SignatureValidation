# ======================================================
# FULL END-TO-END PDF SIGNATURE BLOCK EXTRACTION
# - Keep page number
# - Keep location (bbox)
# - Remove duplicates ONLY if same page + same location
# - Two-pass entropy: normal + watermark detection
# - Mild background reduction in RGB for watermark blocks
# ======================================================

from pdf2image import convert_from_path
from PIL import Image
import numpy as np
import cv2
import matplotlib.pyplot as plt

# ======================================================
# 1. Read PDF pages
# ======================================================
pages = convert_from_path("document.pdf", dpi=300)

# ======================================================
# 2. Helpers
# ======================================================

def calculate_entropy(pil_img):
    arr = np.array(pil_img)
    # handle grayscale or RGB
    if len(arr.shape) == 3 and arr.shape[2] == 3:
        gray = cv2.cvtColor(arr, cv2.COLOR_RGB2GRAY)
    else:
        gray = arr
    hist = np.histogram(gray.flatten(), bins=256)[0]
    hist = hist / hist.sum()
    entropy = -np.sum(hist * np.log2(hist + 1e-8))
    return entropy

def detect_rectangles(pil_img, min_area=1000):
    img_np = np.array(pil_img)
    img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)

    gray = cv2.cvtColor(img_cv, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(blur, 50, 150)

    contours, _ = cv2.findContours(
        edges,
        cv2.RETR_EXTERNAL,
        cv2.CHAIN_APPROX_SIMPLE
    )

    rects = []
    for c in contours:
        approx = cv2.approxPolyDP(
            c,
            0.02 * cv2.arcLength(c, True),
            True
        )

        if len(approx) == 4:
            x, y, w, h = cv2.boundingRect(approx)
            if w * h > min_area:
                rects.append((x, y, w, h))

    return rects

# duplicate check ONLY within same page + almost same location
def is_duplicate_same_page(new_rect, existing_rects, tol=10):
    x1, y1, w1, h1 = new_rect

    for (x2, y2, w2, h2) in existing_rects:
        if (
            abs(x1 - x2) < tol and
            abs(y1 - y2) < tol and
            abs(w1 - w2) < tol and
            abs(h1 - h2) < tol
        ):
            return True

    return False

# ======================================================
# 2a. Background suppression for watermark detection
# ======================================================
def remove_background_for_filtering(pil_img):
    """
    Suppress background for watermark detection.
    Keeps printed text + signature intact.
    """
    gray = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2GRAY)

    # Morphological opening to estimate background
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (35,35))
    background = cv2.morphologyEx(gray, cv2.MORPH_OPEN, kernel)

    # Subtract background
    fg = cv2.subtract(gray, background)

    # Normalize to full range
    fg = cv2.normalize(fg, None, 0, 255, cv2.NORM_MINMAX)

    return Image.fromarray(fg)

# ======================================================
# 2b. Mild background reduction in original RGB
# ======================================================
def mild_background_reduction_white_bg(pil_img):
    img_rgb = np.array(pil_img).astype(np.uint8)
    lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2LAB)
    l, a, b = cv2.split(lab)

    # Morphological opening to estimate background
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (35,35))
    background = cv2.morphologyEx(l, cv2.MORPH_OPEN, kernel)

    # Subtract background to get foreground
    fg = cv2.subtract(l, background)

    # Invert fg so background becomes white
    fg_inverted = cv2.bitwise_not(fg)

    # Normalize to full range (0=black text, 255=white background)
    l_reduced = cv2.normalize(fg_inverted, None, 0, 255, cv2.NORM_MINMAX)

    # Merge back channels
    lab_reduced = cv2.merge([l_reduced, a, b])
    img_reduced = cv2.cvtColor(lab_reduced, cv2.COLOR_LAB2RGB)

    return Image.fromarray(img_reduced)

# ======================================================
# 3. Process all pages with two-pass entropy
# ======================================================
LOW_ENTROPY = 2.0
HIGH_ENTROPY_CANDIDATE = 4.5  # possible watermark blocks

final_crops = []

for page_idx, page in enumerate(pages):

    rects = detect_rectangles(page)

    # remove duplicates only within THIS page
    unique_rects = []
    for r in rects:
        if not is_duplicate_same_page(r, unique_rects):
            unique_rects.append(r)

    # crop + entropy filter
    for (x, y, w, h) in unique_rects:
        crop = page.crop((x, y, x+w, y+h))
        entropy = calculate_entropy(crop)

        # 1️⃣ normal signature block
        if entropy < LOW_ENTROPY:
            final_crops.append({
                "page": page_idx + 1,
                "bbox": (x, y, w, h),
                "entropy": entropy,
                "image": crop
            })
            continue

        # 2️⃣ high-entropy watermark candidates
        if entropy < HIGH_ENTROPY_CANDIDATE:
            fg_img = remove_background_for_filtering(crop)
            # ensure RGB before entropy to avoid errors
            fg_img_rgb = fg_img.convert("RGB")
            new_entropy = calculate_entropy(fg_img_rgb)

            if new_entropy < LOW_ENTROPY:
                # apply mild background reduction on original RGB image
                mild_img = mild_background_reduction(crop)
                final_crops.append({
                    "page": page_idx + 1,
                    "bbox": (x, y, w, h),
                    "entropy": entropy,
                    "image": mild_img
                })
                print(f"Recovered watermark block at page {page_idx+1}, bbox {(x, y, w, h)}, new entropy={new_entropy:.2f}")

print(f"Total cropped images after filtering: {len(final_crops)}")

# ======================================================
# 4. Display all results
# ======================================================
def show_images_grid(items, cols=3, title="Cropped Images"):
    if len(items) == 0:
        print("No images to display.")
        return

    rows = (len(items) + cols - 1) // cols
    plt.figure(figsize=(5*cols, 5*rows))

    for i, item in enumerate(items):
        plt.subplot(rows, cols, i+1)
        plt.imshow(item["image"])
        plt.axis("off")

        p = item["page"]
        x, y, w, h = item["bbox"]
        plt.title(f"P{p} | ({x},{y})", fontsize=9)

    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    plt.show()

show_images_grid(final_crops, cols=3,
                 title="Final Crops with Mild Background Reduction")
