# ======================================================
# FORENSIC FILTERING + QUARTER ANALYSIS (COMBINED)
# ======================================================

import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt


# ------------------------------------------------------
# 1️⃣ Advanced forensic filtering
# ------------------------------------------------------
def forensic_signature_mask(pil_img):

    gray = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2GRAY)

    _, binary = cv2.threshold(gray, 180, 255, cv2.THRESH_BINARY_INV)

    # ---- remove straight lines ----
    horizontal_kernel = cv2.getStructuringElement(
        cv2.MORPH_RECT, (40,1)
    )
    horizontal_lines = cv2.morphologyEx(
        binary, cv2.MORPH_OPEN, horizontal_kernel
    )

    vertical_kernel = cv2.getStructuringElement(
        cv2.MORPH_RECT, (1,40)
    )
    vertical_lines = cv2.morphologyEx(
        binary, cv2.MORPH_OPEN, vertical_kernel
    )

    binary = cv2.subtract(binary, horizontal_lines)
    binary = cv2.subtract(binary, vertical_lines)

    # ---- remove bold text (light erosion) ----
    erosion_kernel = np.ones((2,2), np.uint8)
    binary = cv2.erode(binary, erosion_kernel, iterations=1)

    # ---- stroke direction variation ----
    sobelx = cv2.Sobel(binary, cv2.CV_64F, 1,0,ksize=3)
    sobely = cv2.Sobel(binary, cv2.CV_64F, 0,1,ksize=3)

    angle = np.arctan2(sobely, sobelx)
    angle_std = cv2.GaussianBlur(np.abs(angle),(15,15),0)

    mask_variation = (angle_std > 0.5).astype(np.uint8)*255

    binary = cv2.bitwise_and(binary, mask_variation)

    # ---- connected components cleanup ----
    num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(binary,8)

    mask = np.zeros_like(binary)

    for i in range(1,num_labels):

        x,y,w,h,area = stats[i]

        if area > 120:
            mask[labels==i] = 255

    return mask


# ------------------------------------------------------
# 2️⃣ Quarter density analysis
# ------------------------------------------------------
def find_signature_region(mask):

    h, w = mask.shape

    regions = [
        (0, h//2, 0, w//2),
        (0, h//2, w//2, w),
        (h//2, h, 0, w//2),
        (h//2, h, w//2, w)
    ]

    scores = []

    for r in regions:
        y1,y2,x1,x2 = r
        patch = mask[y1:y2, x1:x2]
        score = np.sum(patch > 0)
        scores.append(score)

    best_idx = np.argmax(scores)

    return regions[best_idx]


# ------------------------------------------------------
# 3️⃣ Expand bbox
# ------------------------------------------------------
def expand_bbox(region, shape, margin=30):

    y1,y2,x1,x2 = region
    h,w = shape

    y1 = max(0,y1-margin)
    y2 = min(h,y2+margin)
    x1 = max(0,x1-margin)
    x2 = min(w,x2+margin)

    return y1,y2,x1,x2


# ------------------------------------------------------
# 4️⃣ Final extractor (mask → quarter → original crop)
# ------------------------------------------------------
def extract_signature_final(pil_img):

    mask = forensic_signature_mask(pil_img)

    if np.sum(mask)==0:
        return None

    region = find_signature_region(mask)

    y1,y2,x1,x2 = expand_bbox(region, mask.shape)

    # crop ORIGINAL image (important)
    cropped = pil_img.crop((x1,y1,x2,y2))

    return cropped


# ------------------------------------------------------
# 5️⃣ Run on final_crops
# ------------------------------------------------------
combined_results = []

for item in final_crops:

    if item["entropy"] < 2.0:

        sig_img = extract_signature_final(item["image"])

        combined_results.append({
            "page": item["page"],
            "bbox": item["bbox"],
            "signature": sig_img
        })


# ------------------------------------------------------
# 6️⃣ Display
# ------------------------------------------------------
def display_results(results):

    for r in results:

        plt.figure(figsize=(4,4))

        if r["signature"] is not None:
            plt.imshow(r["signature"])
        else:
            plt.text(0.5,0.5,"No signature found",ha="center")

        plt.axis("off")
        plt.title(f"P{r['page']} | {r['bbox']}")
        plt.show()


display_results(combined_results)
