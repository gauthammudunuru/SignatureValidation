import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# ==============================
# 1️⃣ Forensic binary mask (no sharpening)
# ==============================
def forensic_signature_mask(pil_img, visualize=False):
    gray = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2GRAY)
    _, binary = cv2.threshold(gray, 180, 255, cv2.THRESH_BINARY_INV)

    # Remove straight lines
    hor_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40,1))
    vert_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1,40))
    binary = cv2.subtract(binary, cv2.morphologyEx(binary, cv2.MORPH_OPEN, hor_kernel))
    binary = cv2.subtract(binary, cv2.morphologyEx(binary, cv2.MORPH_OPEN, vert_kernel))

    # Remove bold letters (erosion)
    binary = cv2.erode(binary, np.ones((2,2), np.uint8), iterations=1)

    if visualize:
        plt.figure(); plt.imshow(binary, cmap='gray'); plt.title("Forensic binary mask"); plt.axis("off"); plt.show()

    return binary

# ==============================
# 2️⃣ Connected components filter
# ==============================
def connected_components_filter(binary, min_area=120, visualize=False):
    num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(binary, 8)
    mask = np.zeros_like(binary)
    for i in range(1, num_labels):
        if stats[i, cv2.CC_STAT_AREA] > min_area:
            mask[labels==i] = 255
    if visualize:
        plt.figure(); plt.imshow(mask, cmap='gray'); plt.title("After connected components"); plt.axis("off"); plt.show()
    return mask

# ==============================
# 3️⃣ Mask original image & binarize
# ==============================
def mask_and_binarize_original(original_img, visualize=False):
    # Step 1: forensic mask
    binary_mask = forensic_signature_mask(original_img)
    # Step 2: connected component filtering
    mask_cc = connected_components_filter(binary_mask)

    # Apply mask to original RGB image
    orig_np = np.array(original_img)
    mask_3c = cv2.merge([mask_cc]*3)
    masked_rgb = cv2.bitwise_and(orig_np, mask_3c)

    # Convert to grayscale for binarization
    gray = cv2.cvtColor(masked_rgb, cv2.COLOR_RGB2GRAY)
    _, binarized = cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY_INV)

    # Convert back to RGB
    binarized_rgb = cv2.cvtColor(binarized, cv2.COLOR_GRAY2RGB)
    result_pil = Image.fromarray(binarized_rgb)

    if visualize:
        plt.figure(); plt.imshow(result_pil); plt.title("Masked + Binarized"); plt.axis("off"); plt.show()

    return result_pil

# ==============================
# 4️⃣ Crop left-bottom quarter
# ==============================
def crop_left_bottom_quarter(pil_img, visualize=False):
    w, h = pil_img.size
    x1, y1 = 0, h//2
    x2, y2 = w//2, h
    cropped = pil_img.crop((x1, y1, x2, y2))

    if visualize:
        plt.figure(); plt.imshow(cropped); plt.title("Left-bottom quarter"); plt.axis("off"); plt.show()

    return cropped

# ==============================
# 5️⃣ Run on final_crops
# ==============================
results = []

for item in final_crops:
    if item["entropy"] < 2.0:
        processed_img = mask_and_binarize_original(item["image"], visualize=True)
        left_bottom = crop_left_bottom_quarter(processed_img, visualize=True)
        results.append({
            "page": item["page"],
            "bbox": item["bbox"],
            "signature_image": left_bottom
        })

# ==============================
# 6️⃣ Display final signature images
# ==============================
def display_results(results):
    for r in results:
        plt.figure(figsize=(4,4))
        plt.imshow(r["signature_image"])
        plt.axis("off")
        plt.title(f"P{r['page']} | {r['bbox']}")
        plt.show()

display_results(results)
