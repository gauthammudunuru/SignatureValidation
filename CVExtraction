import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# ==============================
# 1️⃣ Connected components filter
# ==============================
def connected_components_filter(binary, min_area=120, visualize=False):
    num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(binary, 8)
    mask = np.zeros_like(binary)
    for i in range(1, num_labels):
        if stats[i, cv2.CC_STAT_AREA] > min_area:
            mask[labels==i] = 255
    if visualize:
        plt.figure(); plt.imshow(mask, cmap='gray'); plt.title("After connected components"); plt.axis("off"); plt.show()
    return mask

# ==============================
# 2️⃣ Forensic binary mask (no sharpening)
# ==============================
def forensic_signature_mask(pil_img, visualize=False):
    gray = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2GRAY)
    _, binary = cv2.threshold(gray, 180, 255, cv2.THRESH_BINARY_INV)

    # Remove straight lines
    hor_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40,1))
    vert_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1,40))
    binary = cv2.subtract(binary, cv2.morphologyEx(binary, cv2.MORPH_OPEN, hor_kernel))
    binary = cv2.subtract(binary, cv2.morphologyEx(binary, cv2.MORPH_OPEN, vert_kernel))

    # Remove bold letters (erosion)
    binary = cv2.erode(binary, np.ones((2,2), np.uint8), iterations=1)

    if visualize:
        plt.figure(); plt.imshow(binary, cmap='gray'); plt.title("Forensic binary mask"); plt.axis("off"); plt.show()

    return binary

# ==============================
# 3️⃣ Mask original image with connected components
# ==============================
def mask_original_with_cc(original_img, visualize=False):
    # Step 1: get binary forensic mask
    binary_mask = forensic_signature_mask(original_img)
    # Step 2: connected component filtering
    mask_cc = connected_components_filter(binary_mask)

    # Convert mask to 3-channel for RGB multiplication
    mask_rgb = cv2.merge([mask_cc]*3)
    orig_np = np.array(original_img)

    # Apply mask: keep only non-zero pixels
    result = cv2.bitwise_and(orig_np, mask_rgb)

    # Convert back to PIL
    result_pil = Image.fromarray(result)

    if visualize:
        plt.figure(); plt.imshow(result_pil); plt.title("Original image masked by CC"); plt.axis("off"); plt.show()

    return result_pil

# ==============================
# 4️⃣ Run on final_crops
# ==============================
results = []

for item in final_crops:
    if item["entropy"] < 2.0:
        masked_img = mask_original_with_cc(item["image"], visualize=True)
        results.append({
            "page": item["page"],
            "bbox": item["bbox"],
            "signature_image": masked_img
        })

# ==============================
# 5️⃣ Display final signature images
# ==============================
def display_results(results):
    for r in results:
        plt.figure(figsize=(4,4))
        plt.imshow(r["signature_image"])
        plt.axis("off")
        plt.title(f"P{r['page']} | {r['bbox']}")
        plt.show()

display_results(results)
